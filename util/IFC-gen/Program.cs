using System;
using System.Collections.Generic;
using System.Reflection;
using System.IO;
using System.Linq;

namespace IFC_dotnet_generate
{
	class ParameterInfo
	{
		public string TypeName {get;set;}

		public string Name {get;set;}

		public string CorrespondingPropertyName{get;set;}

		public bool IsInherited {get;set;}

		public ParameterInfo(string typeName, string name, string correspondingPropertyName, bool isInherited)
		{
			TypeName = typeName;
			if(TypeName.StartsWith("Ifc") && TypeName != "IfcSystem"){
				TypeName = TypeName.Remove(0,3);
			}
			Name = name;
			CorrespondingPropertyName = correspondingPropertyName;
			IsInherited = isInherited;
		}

		internal string ToPropertyDeclaration(){
			var propertyDecl = $"\t\tpublic {TypeName} {CorrespondingPropertyName} {{get;set;}}";
			return propertyDecl;
		}
	}

	class ClassInfo
	{
		public string ClassName{get;set;}

		public string BaseClassName{get;set;}

		public bool IsInherited{get;set;}

		public List<ParameterInfo> Parameters {get;set;}

		public ClassInfo(Type classType ){
			ClassName = classType.Name;
			if(ClassName.StartsWith("Ifc") && ClassName != "IfcSystem" && ClassName != "IfcObject"){
				ClassName = ClassName.Remove(0,3);
			}
			IsInherited = classType.BaseType != null;
			if(IsInherited){
				BaseClassName = classType.BaseType.Name;
				if(BaseClassName.StartsWith("Ifc") && BaseClassName != "IfcSystem" && BaseClassName != "IfcObject"){
					BaseClassName = BaseClassName.Remove(0,3);
				}
			}
			Parameters = new List<ParameterInfo>();
		}

		/// <summary>
		/// Create a string containing the parameters.
		/// </summary>
		/// <returns></returns>
		private string ToParameterString(){
			return string.Join(",\n\t\t\t\t", Parameters.Select(i=>$"{i.TypeName} {i.Name}"));
		}

		/// <summary>
		/// Create a string containing the inherited parameters.
		/// </summary>
		/// <returns></returns>
		private string ToInheritedParameterString(){
			if(!IsInherited){
				return string.Empty;
			}
			return string.Join(",\n\t\t\t\t", Parameters.Where(p=>p.IsInherited && !p.Name.EndsWith("Specified")).Select(i=>$"{i.TypeName} {i.Name}"));
		}

		/// <summary>
		/// Create a string containing the parameters to the base type constructor.
		/// </summary>
		/// <returns></returns>
		private string ToBaseParameterString(){
			if(!IsInherited){
				return string.Empty;
			}
			return string.Join(",\n\t\t\t\t", Parameters.Where(p=>p.IsInherited && !p.Name.EndsWith("Specified")).Select(i=>$"{i.Name}"));
		}

		/// <summary>
		/// Create a multi-line string assigning parameters to properties.
		/// </summary>
		/// <returns></returns>
		private string ToFieldAssignmentString(){
			var fieldAssignments = string.Join(";\n", Parameters.Where(p=>!p.IsInherited && !p.Name.EndsWith("Specified")).Select(i=>$"\t\t\tthis.{i.CorrespondingPropertyName} = {i.Name}"));
			return fieldAssignments + ";";
		}

		private string ToPropertiesString(){
			var propertiesString = string.Join("\n\n", Parameters.Where(p=>!p.IsInherited && !p.Name.EndsWith("Specified")).Select(i=>i.ToPropertyDeclaration()));
			return propertiesString;
		}

		/// <summary>
		/// Create a string representing the definition of the class.
		/// </summary>
		/// <returns></returns>
		public string ToClassDefinition(){

			var classSignature = IsInherited?
				$"{ClassName} : {BaseClassName}":
				$"{ClassName}";
			
			string inheritedParameterString = ToInheritedParameterString();
			var parameterString = IsInherited?
				ToParameterString():
				$"{ToParameterString()}, {ToInheritedParameterString()}";
			
			var constructorSignature = IsInherited?
				$"({parameterString}) : base({ToBaseParameterString()})":
				$"({parameterString})";
			
			var classStr = 
$@"/*
This code was generated by a tool. DO NOT MODIFY this code manually, unless you really know what you are doing.
 */
using System;
				
namespace IFC4
{{
	/// <summary>
	/// 
	/// </summary>
	public class {classSignature} 
	{{
{ToPropertiesString()}

		public {ClassName}{constructorSignature}
		{{
{ToFieldAssignmentString()}
		}}
	}}
}}";
			return classStr;
		}

		public string ToComments()
		{
			//http://www.buildingsmart-tech.org/ifc/IFC4/final/html/schema/ifcproductextension/lexical/ifcbuilding.htm
			return string.Empty;
		}
	}

	class Program
	{
		static void Main(string[] args)
		{
			if(args.Length != 2)
			{
				Console.WriteLine("Usage: IFC-dotnet-generate.exe <path to IFC dll> <output directory>");
				return;
			}

			if(!File.Exists(args[0]))
			{
				Console.WriteLine("The specified file does not exist.");
				return;
			}

			if(!Directory.Exists(args[1]))
			{
				Console.WriteLine("The specified output directory does not exist.");
			}

			var asm = Assembly.LoadFrom(args[0]);
			var types = asm.GetTypes().Where(t=>t.IsPublic && t.IsClass);
			foreach (var t in types)
			{
				if(t.Name == "Entity" || t.Name == "IfcRoot")
				{
					continue;
				}

				var classInfo = GenerateClassInfo(t);
				var classStr = classInfo.ToClassDefinition();
				var csPath = Path.Combine(args[1], $"{classInfo.ClassName}.cs");

				File.WriteAllText(csPath, classStr);
			}
		}

		private static ClassInfo GenerateClassInfo(Type t)
		{
			var classInfo = new ClassInfo(t);

			foreach(var p in t.GetProperties())
			{
				if(p.DeclaringType.Name == "Entity" || p.DeclaringType.Name == "IfcRoot")
				{
					continue;
				}

				var pName = p.Name.First().ToString().ToLower() + String.Join("", p.Name.Skip(1));
				
				// Avoid properties named with reserved words.
				if(pName == "ref")
				{
					pName = "reference";
				}

				if(pName == "operator")
				{
					pName = "op";
				}

				classInfo.Parameters.Add(new ParameterInfo(p.PropertyType.Name, pName, p.Name, p.DeclaringType != t));
			}

			return classInfo;
		}
	}
}
