using System;
using System.Collections.Generic;
using System.Reflection;
using System.IO;
using System.Linq;

namespace IFC_dotnet_generate
{
	class ParameterInfo
	{
		public string TypeName {get;set;}

		public string Name {get;set;}

		public bool IsInherited {get;set;}

		public ParameterInfo(string typeName, string name, bool isInherited)
		{
			TypeName = typeName;
			Name = name;
			IsInherited = isInherited;
		}
	}

	class ClassInfo
	{
		public string ClassName{get;set;}

		public string BaseClassName{get;set;}

		public bool IsInherited{get;set;}

		public List<ParameterInfo> Parameters {get;set;}

		public ClassInfo(Type classType ){
			ClassName = classType.Name;
			IsInherited = classType.BaseType != null;
			if(IsInherited){
				BaseClassName = classType.BaseType.Name;
			}
			Parameters = new List<ParameterInfo>();
		}

		/// <summary>
		/// Create a string containing the parameters.
		/// </summary>
		/// <returns></returns>
		private string ToParameterString(){
			return string.Join(",\n\t\t\t\t", Parameters.Select(i=>$"{i.TypeName} {i.Name}"));
		}

		/// <summary>
		/// Create a string containing the inherited parameters.
		/// </summary>
		/// <returns></returns>
		private string ToInheritedParameterString(){
			if(!IsInherited){
				return string.Empty;
			}
			return string.Join(",\n\t\t\t\t", Parameters.Where(p=>p.IsInherited).Select(i=>$"{i.TypeName} {i.Name}"));
		}

		/// <summary>
		/// Create a string containing the parameters to the base type constructor.
		/// </summary>
		/// <returns></returns>
		private string ToBaseParameterString(){
			if(!IsInherited){
				return string.Empty;
			}
			return string.Join(",\n\t\t\t\t", Parameters.Where(p=>p.IsInherited).Select(i=>$"{i.Name}"));
		}

		/// <summary>
		/// Create a multi-line string assigning parameters to properties.
		/// </summary>
		/// <returns></returns>
		private string ToFieldAssignmentString(){
			var fieldAssignments = string.Join(";\n", Parameters.Where(p=>!p.IsInherited).Select(i=>$"\t\t\tthis.{i.Name}Field = {i.Name}"));
			return fieldAssignments + ";";
		}

		/// <summary>
		/// Create a string representing the definition of the class.
		/// </summary>
		/// <returns></returns>
		public string ToClassDefinition(){

			var classSignature = IsInherited?
				$"{ClassName} : {BaseClassName}":
				$"{ClassName}";

			string inheritedParameterString = ToInheritedParameterString();
			var parameterString = IsInherited?
				ToParameterString():
				$"{ToParameterString()}, {ToInheritedParameterString()}";
			
			var constructorSignature = IsInherited?
				$"({parameterString}) : base({ToBaseParameterString()})":
				$"({parameterString})";
			
			var classStr = 
$@"/*
This code was generated by a tool. DO NOT MODIFY this code manually, unless you really know what you are doing.
 */
using System;
				
namespace IFC4
{{
	/// <summary>
	/// 
	/// </summary>
	public partial class {classSignature} 
	{{
		public {ClassName}{constructorSignature}
		{{
{ToFieldAssignmentString()}
		}}
	}}
}}";
			return classStr;
		}

		public string ToComments()
		{
			//http://www.buildingsmart-tech.org/ifc/IFC4/final/html/schema/ifcproductextension/lexical/ifcbuilding.htm
			return string.Empty;
		}
	}

	class Program
	{
		static void Main(string[] args)
		{
			if(args.Length != 2)
			{
				Console.WriteLine("Usage: IFC-dotnet-generate.exe <path to IFC dll> <output directory>");
				return;
			}

			if(!File.Exists(args[0]))
			{
				Console.WriteLine("The specified file does not exist.");
				return;
			}

			if(!Directory.Exists(args[1]))
			{
				Console.WriteLine("The specified output directory does not exist.");
			}

			var asm = Assembly.LoadFrom(args[0]);
			var types = asm.GetTypes().Where(t=>t.IsPublic && t.IsClass);
			foreach (var t in types)
			{
				var classInfo = GenerateClassInfo(t);
				var classStr = classInfo.ToClassDefinition();
				//Console.WriteLine(classStr);
				var csPath = Path.Combine(args[1], $"{t.Name}.cs");

				File.WriteAllText(csPath, classStr);
			}
		}

		private static ClassInfo GenerateClassInfo(Type t)
		{
			var classInfo = new ClassInfo(t);

			foreach(var p in t.GetProperties())
			{
				var pName = p.Name.First().ToString().ToLower() + String.Join("", p.Name.Skip(1));
				
				// Avoid properties named with reserved words.
				if(pName == "ref")
				{
					pName = "reference";
				}

				if(pName == "operator")
				{
					pName = "op";
				}

				classInfo.Parameters.Add(new ParameterInfo(p.PropertyType.Name, pName, p.DeclaringType != t));
			}

			return classInfo;
		}
	}
}
